1. **Produce a Dockerfile for the sample NodeJS app**:
   - **File:** `Dockerfile`
   - **Explanation:** 
   - Created a Dockerfile in the root directory of our NodeJS app project.
   - **Steps include:**
      - Specifying the Node.js Official image.
      - Setting the working directory in the container.
      - Copying dependencies to the working directory.
      - Running the command to install dependencies.
      - Copying application code to the working directory.
      - Using a smaller base image for the final image (`FROM node:14-alpine`).
      - Exposing port 3000.
      - Defining the startup command.
   - **Command:** `docker build -t manojmovva/sample-nodejs:v1.0 .`

 
2. **Push the image generated by the Dockerfile into DockerHub and tag it as "v1.0"**:
   - **Command:** `docker push manojmovva/sample-nodejs:v1.0`
   - **Link:** [DockerHub Repository](https://hub.docker.com/r/manojmovva/sample-nodejs)
   - **Explanation:** After building the Docker image by using the Dockerfile, tag it with the version "v1.0" and pushed it to my DockerHub repository.

3. **Created the Deployment YAML File to deploy the image into a Kubernetes cluster**:
   - **File:** `deployment.yaml`
   - **Command:** 
         ```
            kubectl apply -f deployment.yml
            kubectl get pods
         ```
   - **Explanation:** 
    - Written a Kubernetes Deployment YAML file specifying the container image, ports, replicas, and other configurations. 
    - This YAML file is used to deploy the application to the Kubernetes cluster.

   **Configure Services**

   - **File:** `service.yaml`
   - **Command:** 
      ```
      kubectl apply -f service.yaml
      kubectl get services
      ```
   - **Explanation:** 
   - Defined a Kubernetes Service YAML file to expose the deployed application within the cluster or to external traffic.
   - This file specifies the service type, ports, and selectors for routing traffic to pods.


4. **Create a YAML file that generates an Ingress for the cluster**:
   - **File:** `ingress.yaml`
   - **Command:** 
      ```
         kubectl apply -f ingress.yaml
         kubectl get ingresses
         kubectl get ingresses -n <namespace_name>
      ```
   - **Explanation:** Defined an Ingress resource in a YAML file to configure external access to services within the Kubernetes cluster. Specify routing rules, paths, and backend services. To configure Ingress in the cluster.

5. **Provide YAML file to create a new namespace called "monitoring"**:
   - **File:** `monitoring-namespace.yaml`
   - **Command:** `kubectl apply -f monitoring-namespace.yaml`
   - **Explanation:** Kubernetes Namespace YAML file to create a new namespace named "monitoring". Namespaces are used to organize and isolate resources within a Kubernetes cluster.

6. **Provide YAML file to deploy Prometheus and Grafana to the "monitoring" namespace**:
   - **File:** `monitoring-components.yaml`
   - **Command:** 
      ```
      kubectl apply -f monitoring-components.yaml
      kubectl get all -n monitoring
      kubectl get pods -n monitoring
      kubectl get deployments -n monitoring

      ```
   - **Explanation:** Define YAML files for deploying Prometheus and Grafana to the "monitoring" namespace. These files should include configurations for ServiceAccounts, Deployments, Services for monitoring.

7. **Ensure application stops if Kubernetes job exceeds 40 seconds**:
   - **File:** `timeout-job.yaml`
   - **Command:** 
      ```
      kubectl apply -f timeout-job.yaml
      kubectl describe job timeout-sample-nodejs-job
      ```
   - Explanation: The Job YAML file `timeout-job.yaml` to include a timeout value using the `activeDeadlineSeconds` field. Set this value to 40 seconds to ensure the job terminates if it exceeds this duration.

8. **Deploy app exclusively on node with GPU**:
   - Explanation: `timeout-job.yaml` YAML file to include node affinity or node selector configurations. These configurations ensure that the application pods are scheduled only on nodes with GPU resources.

9. **Pull container from alternative source (e.g., Azure Repos)**:
   - Explanation: Modify the image path (registry.azurecr.io/sample-nodejs:v1.0) in the Deployment YAML file to point to the container registry of the alternative source (e.g., Azure Repos). 
   ``` 
       imagePullSecrets: 
       - name: azure-registry-secret
   ```
    Kubernetes secret containing Azure registry credentials.

10. **Describe logging infrastructure for centralized logging**:
    - Explanation: Implement logging agents **Fluentd, Filebeat** on each node to collect container logs. Send these logs to a centralized logging system like **Elasticsearch, Splunk** for storage, indexing, and analysis.

11. **Configure read-only kubectl access for developers**:
    - Files: `readonly-role.yaml`, `readonly-role-binding.yaml`
    - Commands: 
       ```
         kubectl apply -f readonly-role.yaml
         kubectl describe role readonly-role
         kubectl get roles
         kubectl get roles -n <namespace_name>

         kubectl apply -f readonly-role-binding.yaml
         kubectl get rolebindings
         kubectl get rolebindings -n <namespace_name>


       ```
    - Explanation: Define Role and RoleBinding YAML files to create a read-only role with permissions to view resources. Apply these files to grant developers read-only access to the Kubernetes cluster.

12. **Suggest other architectural components for high availability and reliability**:
    - Explanation: Consider implementing components such as load balancers, multi-zone deployment, cluster autoscaling, service mesh (e.g., Istio), and backup and disaster recovery solutions to enhance the high availability and reliability of the Kubernetes cluster. These components improve fault tolerance, scalability, and resilience against failures.


```
**cmds**
```
kubectl apply -f deployment.yml
kubectl get pods
```

```
kubectl apply -f service.yaml
kubectl get services
```
```
kubectl apply -f ingress.yaml
kubectl get ingresses
kubectl get ingresses -n <namespace_name>

```

```
kubectl apply -f monitoring-namespace.yaml
kubectl get namespaces
```

```
kubectl apply -f monitoring-components.yaml
kubectl get all -n monitoring
kubectl get pods -n monitoring
kubectl get deployments -n monitoring

```
```
kubectl apply -f timeout-job.yaml
kubectl describe job timeout-sample-nodejs-job
```
```
kubectl get jobs
kubectl describe job timeout-sample-nodejs-job
```
```
kubectl apply -f readonly-role.yaml
kubectl describe role readonly-role
kubectl get roles
kubectl get roles -n <namespace_name>

```
kubectl apply -f readonly-role-binding.yaml
kubectl get rolebindings
kubectl get rolebindings -n <namespace_name>


```